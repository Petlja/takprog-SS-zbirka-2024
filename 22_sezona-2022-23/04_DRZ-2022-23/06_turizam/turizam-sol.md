---
title: Туризам - опис решења
---

# Туризам

Аутор: Јован Бенгин
Текст и тест примери: Јован Бенгин
Анализа решења: Јован Бенгин
Тестирање: Игор Павловић

### Анализа
Прво, приметимо да ћемо увек посетити неки подниз који садржи почетно поље $x$. Ако је подниз који посетимо $[L, R]$, НР на крају ће бити $A_L \ \text{and} \ A_{L+1} \ \text{and} \ \ldots{} \ \text{and} \ A_R$ (записаћемо као $f(L, R)$), а минималан број корака да се посети је $R - L + min(x - L, R - x)$ (тако што из почетка одемо до леве границе, па до десне, или обрнуто).

### Решење првог подзадатка

У овом подзадатку можемо итерирати кроз сваку могућу леву и десну границу, и укупну $\text{and}$ вредност рачунати једним проласком кроз подниз.

Укупна сложеност: ${\mathcal O}(QN^3)$

### Решење другог подзадатка
 
 Исто ћемо итерирати кроз сваку могућу леву и десну границу, али ћемо чувати вредности $f(L, x)$ и $f(x, R)$ и ажурирати их током итерација. Сада не морамо да итерирамо кроз цео подниз да бисмо нашли $f(L, R)$, већ га добијемо из сачуване две вредности.
 
 Укупна сложеност: ${\mathcal O}(QN^2)$

### Решење трећег подзадатка
За наредне подзадатке потребна нам је још једна кључна опсервација: оптимални подниз ће увек имати леву и десну границу у пољима где се укупан НР мења, тј. у $L$ и $R$ таквим да важи $f(L, x) \neq f(L + 1, x)$ (или $L = x$) и $f(x, R) \neq f(x, R - 1)$ (или $R = x$). Ово је тачно јер, ако је на граници поље које не мења НР, можемо га само избацити из подниза.

У овом подзадатку је, дакле, могуће само неколико случајева: да директно идемо из $x$ у најближу нулу, да идемо из $x$ до најближе леве јединице и до најближе десне двојке (или обрнуто), или да, ако су жељена јединица и двојка са исте стране, одемо из $x$ до даље од њих.

Позиције најближе леве и десне нуле, јединице и двојке можемо наћи преко структуре *std::set* и њене функције *upper_bound*.

Укупна сложеност: ${\mathcal O}(QlogN)$

### Решење четвртог подзадатка

Позиције које мењају НР су заправо оне за које важи да постоји неки бит који се не налази у њеном елементу, али се налази у елементима на свим позицијама од ње до $x$.

За сваки бит можемо једним проласком кроз низ наћи најближу леву и десну позицију чији елемент не садржи тај бит, нека су за $i$-ти би те две позиције $l_i$ и $r_i$, а наш интервал мора да садржи или једну или другу. Другим речима, услов можемо да формулишемо као: ако је лева граница већа од $l_i$, онда је десна граница већа једнака $r_i$.
Зато можемо да итерирамо кроз сортиран низ потенцијалних левих граница (којих има $log(A_i)$) и да одржавамо тренутну минималну десну границу, и тако налазимо минимално решење.

Сложеност овог алгоритма је  ${\mathcal O}(QNlog(A_i))$, што би уз покоју оптимизацију прошло. Међутим, налажење левих и десних граница може да се уради у ${\mathcal O}(N + log(A_i))$ уместо ${\mathcal O}(Nlog(A_i))$, тако што почнемо из $x$ и крећемо се лево или десно (у зависности од тога коју границу налазимо), чувајући тренутну $\text{and}$ вредност тог интервала. Када се та вредност промени, итерирамо кроз оне битове где се променила и за њих одређујемо да им је граница на тој позицији.

Укупна сложеност: ${\mathcal O}(Q(N + log(A_i)))$

### Решење петог подзадатка

У овом подзадатку ћемо брже налазити позиције нула: за сваки бит чувамо низ позиција чији елементи немају тај бит. Сада можемо бинарном претрагом да брзо нађемо жељене елементе.

Укупна сложеност: ${\mathcal O}(Qlog(N)log(A_i))$

### Главно решење

Главно решење се ради на исти начин као пети подзадатак, само што се уместо низа позиција користи структура *std::set*, која се лако може ажурирати у случају догађаја првог типа.

Укупна сложеност: ${\mathcal O}(Qlog(N)log(A_i))$
