---
title: Ваге - опис решења
---

# Ваге

Аутор: Младен Пузић
Текст и тест примери: Младен Пузић
Тестирање: Алекса Милисављевић
Анализа решења: Младен Пузић

### Решење када $N, M \leq 1000$
За свако питање можемо једноставно проћи кроз све битне ваге и проверити да ли могу измерити тренутно $x_i$. 

Временска сложеност је $O(NM)$, а меморијска $O(N)$.

### Решење када $d_i=u_i$
У овом случају потребно је одредити, за свако питање, колико вага којима је $d_i$ једнако $x_i$ има индекс од $l_i$ до $r_i$. Пошто нам нису битне конкретне вредности $d_i$, $u_i$ и $x_i$, већ само да ли су једнаки, ове вредности можемо компресовати, на пример користећи *std::map*, тако да све буду највише $N$. Када то урадимо, можемо за сваки различит елемент у низу $d_i$ да направимо нови низ, који садржи, сортирано растуће, све индексе вага којима одговара та вредност $d_i$. 

Сада, кад је потребно да одговоримо на питање, можемо користећи бинарну претрагу да нађемо колико елемената у низу индекса који одговара вредности $x_i$ се налази на интервалу $[l_i, r_i]$.

Временска сложеност је $O((N+M)logN)$, а меморијска $O(N)$.

### Решење када не постоји $x$ које могу да измере две различите ваге

Овај услов се другачије може написати да су интервали $[d_i, u_i]$ дисјунктни. Сортирајмо интервале по левој граници, такође чувајући индекс сваког интервала. Након тога решавамо питања једно по једно, тако што бинарном претрагом тражимо последњи интервал коме је лева граница мања од тренутног $x_i$.  

Уколико се $x_i$ не налази у том интервалу или се индекс тог интервала не налази у интервалу $[l_i, r_i]$, резултат за тренутно питање је $0$. У супротном, резултат је $1$.

Временска сложеност је $O((N+M)logN)$, а меморијска $O(N)$.

### Решење када $u_i \leq 20$
Овај случај се решава слично случају када важи $d_i = u_i$, с тим што, уместо да убацимо сваки индекс у низ индекса само за вредност $d_i$, ми ћемо га убацити у низ индекса за сваку вредност у интервалу $[d_i, u_i]$. Након тога, одговор на питање налазимо на исти начин као раније. Потребно је посебно пазити за случај када $x_i > 20$. 

Временска сложеност је $O(N\cdot max(u_i) + MlogN)$, а меморијска $O(N)$.

### Главно решење
Како бисмо решили задатак за све бодове, потребно је да на питања одговарамо *offline*, односно у другачијем редоследу него што су дата, па ћемо их на крају исписати у тачном редоследу. На питања ћемо одговарати у редоследу растуће по $x_i$ (уколико више питања има исто $x_i$, није битно на које одговарамо прво). 

Знамо да нам је вага $j$ битна само ако важи $d_j \leq x_i \leq u_j$. Дакле, како идемо кроз питања растуће по $x_i$, постоје две врсте догађаја: 

- Вага $j$ постаје битна први пут када постављамо питање за које важи $x_i \geq d_j$;
- Вага $j$ престаје да буде битна при пут када постављамо питање за које важи $x_i \geq u_j+1$.

Убацимо свих $2N$ догађаја у један низ и сортирајмо га растуће по њиховим границама за $x_i$. Сада можемо заједно пролазити кроз низ питања и низ догађаја методом два показивача и одржавати низ нула и јединица дужине $N$ који на $i$-тој позицији садржи $1$ ако и само ако је вага са индексом $i$ тренутно битна. Наравно, овај низ ћемо мењати сваки пут када на ред дође неки нови догађај.

Како бисмо ефикасно одговорили на питање, потребно је да ефикасно нађемо збир на интервалу $[l_i, r_i]$ овог низа, у тренутку када смо обрадили све догађаје који долазе пре овог питања. За ово можемо користити сегментно или Фенвиково стабло како бисмо остварили добру сложеност.

Временска сложеност је $O((N+M)logN)$, а меморијска $O(N)$.
