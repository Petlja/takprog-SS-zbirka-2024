# Компресовани низ

Аутор: Алекса Милисављевић
Текст и тест примери: Алекса Милисављевић 
Анализа решења: Алекса Милисављевић
Тестирање:  Владимир Миленковић

### Решење када $N \leq 10$

У овом подзадатку можемо тестирати сваки могући низ примене операција. За дато $K$ имамо $N-K+1 = (N - (K-1))$ опција за примену прве операције. После првог корака, број елемената се смањи за $K-1$, па у другом кораку имамо $N-2\cdot(K-1)$ опција. Укупно, постоји $(N-(K-1)) \cdot (N-2\cdot(K-1)) \cdot ... \cdot ( (K-1) + (N\mod(K-1)))$ различитих секвенци операција које резултују низом дужине мање од $K$. Претходни производ је ограничен са $(N-1)!$, па је сложеност овог решења $O(N!)$.


### Решење када $K \leq 3$ и  $N \leq 100.000$

За наредне подзадатке морамо мало детаљније анализирати како примене операција утичу на низ. За овај подзадатак, довољно је приметити да су елементи крајњег низа заправо компресовани блокови узастопних елемената у почетном низу. Ти блокови узастопних елемената имају дужину $1 \mod (K-1)$, што је лако показати. Наиме, у почетном низу блокови имају дужину $1$. Сваком даљом компресијом се $K$ таквих блокова спаја у један блок, који по модулу $K-1$ има дужину $K \cdot 1 = K = 1 \mod (K-1)$. Коначно, за овај подзадатак можемо да анализирамо два слулчаја:
 * $K=2$ - тада крајњи низ има дужину $1$, а вредност тог елемента је $\textbf{or}$ вредности свих елемената у почетном низу
 * $K=3$ - тада крајњи низ има дужину $1$ уколико је $N$ непарно и $2$, уколико је $N$ парно. Уколико је $N$ непарно, тада је вредност јединог елемента $\textbf{or}$ вредности свих елемената у почетном низу. Коначно, уколико је $N$ парно, можемо да итерирамо по завршетку првог блока, који се завршава на неком непарном индексу у почетном низу и да посматрамо префиксни и суфиксни $\textbf{or}$ елемената почетног низа. Решење задатка је минимум њихове суме.

### Решење када $N \le 3.000$

Овај и наредне подзадатке решавамо динамичким програмирањем. Вредност $dp[i]$ ће представљати минималну вредност суме уколико се ограничимо искључиво на првих $i$ елемената низа. Прво морамо приметити да је услов да се операције примењују све док низ има довољно елемената суштински неважан. Наиме, применом операције се сума елемената низа не може повећати, те је свакако увек боље применити што више операција. За сваку позицију $i$, итерирамо по завршној позицији претходног блока. Рекурентна формула за наше динамичко програмирање је $\min_j (dp[j] + A[j+1] \textbf{ or } A[j+2] \textbf{ or } ... \textbf{ or } A[i])$, где је $i - j = 1 \mod (K-1)$ (јер према опсервацији из претходног подзадатак важи да је дужина сваког блока $1 \mod (K-1)$). Уколико одржавамо вредност $A[j+1] \textbf{ or } A[j+2] \textbf{ or } ... \textbf{ or } A[i]$, док итерирамо по $j$, добијамо решење сложености $O(N^2)$.

### Решење када су све вредности у низу $A$ су $1$ или $2$ и $N \le 100.000$

И у овом подзадатку поново посматрамо блокове. Сваки блок има вредност $1$, $2$ или $3$. Међутим, блок који се завршава на некој позицији $i$ може да има само две вредности, а то су $A[i]$ и $3$ (нпр. уколико $i$-ти елемент има вредност $1$, блок који се завршава на позицији $i$ никако не може да има вредност $2$ и обрнуто). За сваку крајњу позицију, фиксирамо једну од те две могуће вредности последњег блока и посматрамо све могуће стартне позиције тренутног блока. За њих можемо да одржавамо минимум користећи неку структуру података, на пример `set`.

### Решење када $N \le 100.000$

Решење овог подзадатка представља надоградњу на решење подзадатка у којем су све вредности у низу $A$ једнаке $1$ или $2$. Можемо да приметимо да постоји највише $\log_2 \max_i A[i] \leq 30$ могућих различитих вредности блока који се завршава на позицији $i$ за свако $i$. Сада можемо да фиксирамо једну од тих вредности и пронађемо најранију позицију (означимо ту позицију са $j$) на којој је тренутни блок могао да почне да би имао ту вредност. Затим, користећи неку структуру, нпр. `set` пронађемо минимум вредности $dp$-ова претходног блока од позиције $j$ па до $i$. Ово можемо да реализујемо користећи `set` на следећи начин. Можемо да чувамо $K-1$ `set`-ова, један за сваку крајњу позиција модуо $K-1$. У сваком од њих можемо да чувамо вредности $dp$-ова сортирано по индексу. Коначно, када убацујемо $dp[i]$ у `set` који одговара модулу $i \mod (K-1)$, треба да избацимо све оне које који се појављују пре њега, а имају већу вредност од $dp[i]$. Када тражимо минимум од позиције $j$ до позиције $i$, можемо да позовемо уграђену функцију `lower_bound`, да бисмо пронашли први индекс већи од $j$ који постоји у одговарајућем `set`-у. Сложеност овог решења је $O(N \log N \log \max_i A[i])$.


### Главно решење
За главно решење и последњи подзадатак, довољно је оптимизовати сложеност на $O(N \log \max_i A[i])$. Ово се може постићи, на пример, тако што заменимо `set` са спарс табелом. 

